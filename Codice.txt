import runloop, motor, motor_pair, math
from hub import light, port, motion_sensor, light_matrix


sensor = port.E
leftMotor = port.B
rightMotor = port.D
rightProt = port.C
leftProt = port.A
motor_pair.pair(motor_pair.PAIR_1, leftMotor, rightMotor)

move_speed = 800
rot_speed = 400

async def main():
    newZero()
    
    #await run1()

    #await run2()

    #await run3()

    #await run4()

    await run5()

async def run1():
    await move_by(49)
    await move_by(-40)

async def run2():
    await move_by(58)
    await move_by(-55)

async def run3():
    move_motor(leftProt, 145, 1)
    await move_by(65)
    #Spazzaterra
    await move_by(-12, a=500)
    await move_by(17.5)

    await gira_di_gradi(90, -1)
    move_motor(leftProt, 150, -1)

    await move_by(28.45)
    #alza carrello
    move_motor(leftProt, 375, 1)
    move_motor(leftProt, 375, -1)

    await move_by(54.5)
    #await gira_di_gradi(5, -1)
    #abbassa cesto
    move_motor(leftProt, 700, 1)
    move_motor(leftProt, 600, -1)

    await move_by(40)
    move_motor(leftProt, 135, 1)
    await move_by(-10)
    move_motor(leftProt, 135, -1)
    await gira_di_gradi(60, -1)
    await move_by(55)

async def run4():
    await move_by(55)
    await runloop.sleep_ms(500)
    move_motor(rightProt, 180, 1, v=660)
    #await runloop.sleep_ms(500)
    move_motor(rightProt, 120, -1, v=660)
    move_motor(rightProt, 120, 1)

async def run5():
    await gira_di_gradi(50, 1)
    await move_by(52)
    await move_by(-50)

def newZero():
    #reset gyro and encoders
    while motion_sensor.stable is False:
        pass

    motion_sensor.reset_yaw(0)
    motor.reset_relative_position(leftMotor, 0)
    motor.reset_relative_position(rightMotor, 0)

async def move_by(cm, *, v = move_speed, s = 0, a = 300):
    light_matrix.write(str(cm))
    d = cmToDeg(abs(cm))
    step = a  * 0.05 if a != 0 else v
    k = sign(cm)
    motor.reset_relative_position(leftMotor,0)
    motor.reset_relative_position(rightMotor,0)
    motor_pair.move(motor_pair.PAIR_1, s, velocity = int(k*step))

    m = v/step
    i = 1

    while (abs(motor.relative_position(leftMotor)) + abs(motor.relative_position(rightMotor)))/2 < d:
        await runloop.sleep_ms(50)
        i += 1
        i = min(i, m)
        motor_pair.move(motor_pair.PAIR_1, s, velocity = int(k*step*i))


    motor_pair.stop(motor_pair.PAIR_1)

def turn_by(amount, *, v = rot_speed):
    v *= 660
    k = sign(amount)
    motor.reset_relative_position(leftMotor,0)
    motor.reset_relative_position(rightMotor,0)
    motor_pair.move(motor_pair.PAIR_1, k*100, velocity = int(v))

    while abs(motor.relative_position(rightMotor)) < abs(amount)*2:
        pass
    motor_pair.stop(motor_pair.PAIR_1)

def move_motor(chosen_motor, rot, d, *, v = rot_speed):
    light_matrix.write(str(rot*d))
    motor.reset_relative_position(chosen_motor, 0)
    motor.run(chosen_motor, d*int(v))
    while abs(motor.relative_position(chosen_motor)) < rot - 20:
        pass
    motor.stop(chosen_motor)

def turn_single(a, side):
    wheel = leftMotor if side == -1 else rightMotor
    motor.reset_relative_position(wheel, 0)
    #motor.run_to_relative_position(a)

def rotation():
    w, x, y, z = motion_sensor.quaternion()
    radianti = math.atan2(2*(w*z + x*y), 1 - 2 * (y*y + z*z))
    return (math.degrees(radianti) + 360) % 360

# La funzione deve essere async
async def gira_di_gradi(gradi_da_ruotare, side):
    start_angle = rotation()
    # Esempio semplificato: calcola il target assoluto
    target = 0
    if side == 1:
        target = (start_angle + gradi_da_ruotare) % 360
    elif side == -1:
        target = (start_angle + 360 - gradi_da_ruotare) % 360

    wheel = leftMotor if side == -1 else rightMotor

    motor.run(wheel, sign(gradi_da_ruotare)*side*250)

    # Ciclo asincrono
    while abs(rotation() - target) > 2: # Tolleranza di 2 gradi
        await runloop.sleep_ms(50) # FONDAMENTALE: permette allo hub di respirare

    motor.stop(wheel)

def cmToDeg(cm):
    return int((cm/(5.6 * 3.1415926535)) * 360)

def angle():
    return motion_sensor.tilt_angles()[0]*0.1

def simplify(a):
    if a < -180:
        return simplify(a + 360)
    if a > 180:
        return simplify(a - 360)
    return a

def sign(x):
    if x < 0:
        return -1
    if x > 0:
        return 1
    return 0

runloop.run(main())